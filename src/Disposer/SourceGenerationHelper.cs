namespace Disposer;

public static class SourceGenerationHelper
{
    internal static string ImplementDisposablePattern(DisposableToGenerate classToGenerate)
    {
        ICsFileBuilder csFileBuilder = new CsFileBuilder();

        csFileBuilder.AddAutoGeneratedHeader("Disposer")
                     .AddEmptyLine();

        if (classToGenerate.ImplementIAsyncDisposable)
            csFileBuilder.AddStatements("#nullable enable")
                         .AddEmptyLine()
                         .AddUsing("ValueTaskAlias = global::System.Threading.Tasks.ValueTask")
                         .AddEmptyLine();

        csFileBuilder.AddNamespace(classToGenerate.Namespace, true);

        GenerateBaseImplementation(csFileBuilder, classToGenerate);

        if (classToGenerate.ImplementDisposable)
            GenerateDisposableImplementation(csFileBuilder, "IDisposable", false, classToGenerate);

        if (classToGenerate.ImplementIAsyncDisposable)
            GenerateDisposableImplementation(csFileBuilder, "IAsyncDisposable", true, classToGenerate);

        csFileBuilder.EndNamespace();

        return csFileBuilder.Build();
    }

    private static void GenerateBaseImplementation(ICsFileBuilder builder, DisposableToGenerate classToGenerate)
    {
        builder.AddStatementAndStartBlock($"partial class {classToGenerate.Name}")
               .AddStatements("[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]",
                                    "private bool disposed = false;")
               .AddProtectedDisposed(classToGenerate.IsSealed)
               .AddEmptyLine()
               .AddFinializer(classToGenerate.Name, !classToGenerate.ImplementDisposable && classToGenerate.ImplementIAsyncDisposable)
               .EndBlock()
               .AddEmptyLine();
    }

    private static void GenerateDisposableImplementation(ICsFileBuilder builder, string interfaceName, bool isAsync, DisposableToGenerate classToGenerate)
    {
        builder.AddStatementAndStartBlock($"partial class {classToGenerate.Name} : global::System.{interfaceName}")
               .AddCallbackFunctions(isAsync, classToGenerate)
               .AddDisposeBoolean(isAsync, classToGenerate)
               .AddEmptyLine()
               .AddDispose(isAsync)
               .EndBlock()
               .AddEmptyLine();
    }

    private static ICsFileBuilder AddProtectedDisposed(this ICsFileBuilder builder, bool isSealed)
    {
        string accessModifier = isSealed ? "private" : "protected";
        builder.AddStatements($"{accessModifier} bool Disposed => disposed;");
        return builder;
    }

    private static ICsFileBuilder AddDispose(this ICsFileBuilder builder, bool isAsync)
    {
        if (isAsync == false)
            builder.AddStatementAndStartBlock("public void Dispose()")
                   .AddStatements("Dispose(true);");
        else
            builder.AddStatementAndStartBlock("public async ValueTaskAlias DisposeAsync()")
                   .AddStatements("await DisposeAsync(true);");

        builder.AddStatements("global::System.GC.SuppressFinalize(this);")
               .EndBlock();

        return builder;
    }

    private static ICsFileBuilder AddCallbackFunctions(this ICsFileBuilder builder, bool isAsync, DisposableToGenerate disposableToGenerate)
    {
        if (!isAsync)
        {
            if (disposableToGenerate.GenerateDisposeManagedCallback)
                builder.AddStatements($"private global::System.Action? DisposeManaged;");

            if (disposableToGenerate.GenerateDisposeUnmanagedCallback)
                builder.AddStatements($"private global::System.Action? DisposeUnmanaged;");

            if (disposableToGenerate.GenerateDisposeManagedCallback ||
                disposableToGenerate.GenerateDisposeUnmanagedCallback)
                builder.AddEmptyLine();
        }
        else
        {
            if (disposableToGenerate.AsyncGenerateDisposeManagedCallback)
                builder.AddStatements($"private global::System.Func<ValueTaskAlias>? DisposeManagedAsync;");

            if (disposableToGenerate.AsyncGenerateDisposeUnmanagedCallback)
                builder.AddStatements($"private global::System.Func<ValueTaskAlias>? DisposeUnmanagedAsync;");

            if (disposableToGenerate.AsyncGenerateDisposeManagedCallback ||
                disposableToGenerate.AsyncGenerateDisposeUnmanagedCallback)
                builder.AddEmptyLine();
        }

        return builder;
    }

    private static ICsFileBuilder AddFinializer(this ICsFileBuilder builder, string className, bool isAsync)
    {
        string statement = isAsync ? "DisposeAsync(false).GetAwaiter().GetResult();" : "Dispose(false);";

        builder.AddStatementAndStartBlock($"~{className}()")
               .AddStatements(statement)
               .EndBlock();

        return builder;
    }

    private static ICsFileBuilder AddDisposeBoolean(this ICsFileBuilder builder,
        bool isAsync,
        DisposableToGenerate disposableToGenerate)
    {
        if (isAsync)
            AddDisposeAsyncBooleanLogic(builder, disposableToGenerate);
        else
            AddDisposeBooleanLogic(builder, disposableToGenerate);

        return builder;
    }

    private static void AddDisposeBooleanLogic(this ICsFileBuilder builder, DisposableToGenerate disposableToGenerate)
    {
        string methodPrefix = disposableToGenerate.IsSealed ? "private" : "protected virtual";
        string[] variablesName = disposableToGenerate.FieldsOrProperties
            .Select(x => GetDisposeStatement(x, false)).ToArray();

        builder.AddStatementAndStartBlock($"{methodPrefix} void Dispose(bool disposing)")
               .AddIfBlock("!disposed", "return;")
               .AddEmptyLine()
               .AddStatementAndStartBlock("if (disposing)")
               .AddStatements(variablesName)
               .AddStatementsIf(disposableToGenerate.GenerateDisposeManagedCallback, "DisposeManaged?.Invoke();")
               .EndBlock()
               .AddStatementsIf(disposableToGenerate.GenerateDisposeUnmanagedCallback, "DisposeUnmanaged?.Invoke();")
               .AddStatements("", "disposed = true;")
               .EndBlock();
    }

    private static void AddDisposeAsyncBooleanLogic(this ICsFileBuilder builder, DisposableToGenerate disposableToGenerate)
    {
        string methodPrefix = disposableToGenerate.IsSealed ? "private" : "protected virtual";
        string[] variablesName = disposableToGenerate.FieldsOrProperties
            .Select(x => GetDisposeStatement(x, true)).ToArray();

        builder.AddStatementAndStartBlock($"{methodPrefix} async ValueTaskAlias DisposeAsync(bool disposing)")
               .AddIfBlock("!disposed", "await ValueTaskAlias.FromResult(ValueTaskAlias.CompletedTask);")
               .AddEmptyLine()
               .AddStatementAndStartBlock("if (disposing)")
               .AddStatements(variablesName)
               .AddStatementsIf(disposableToGenerate.AsyncGenerateDisposeManagedCallback, "await (DisposeManagedAsync?.Invoke() ?? ValueTaskAlias.CompletedTask);")
               .EndBlock()
               .AddStatementsIf(disposableToGenerate.AsyncGenerateDisposeUnmanagedCallback, "await(DisposeUnmanagedAsync?.Invoke() ?? ValueTaskAlias.CompletedTask);")
               .AddStatements("", "disposed = true;")
               .EndBlock();
    }

    public static string GetDisposeStatement(FieldOrPropertyToDispose fieldOrProperty, bool isAsync)
    {
        string needAwait = isAsync && fieldOrProperty.ImplementIAsyncDisposable ? "await" : "";
        string needAsync = isAsync && fieldOrProperty.ImplementIAsyncDisposable ? "Async" : "";

        string disposeStatement = $"{needAwait} {fieldOrProperty.Name}.Dispose{needAsync}();{Environment.NewLine}";
        string setToNullStatement = fieldOrProperty.SetToNull ? $"{fieldOrProperty.Name} = null;{Environment.NewLine}" : "";

        return $"{disposeStatement}{setToNullStatement}";
    }
}